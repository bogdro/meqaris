#!/usr/bin/perl
#
# Copyright (C) 2022 Bogdan 'bogdro' Drozdowski, bogdro (at) users . sourceforge . net
#
# This file is part of Meqaris (Meeting Equipment and Room Invitation System),
#  software that allows booking meeting rooms and other resources using
#  e-mail invitations.
#
#  This program is free software: you can redistribute it and/or modify
#  it under the terms of the GNU Affero General Public License as published by
#  the Free Software Foundation, either version 3 of the License, or
#  (at your option) any later version.
#
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU Affero General Public License for more details.
#
#  You should have received a copy of the GNU Affero General Public License
#  along with this program.  If not, see <http://www.gnu.org/licenses/>.
#

use strict;
use warnings;

use Config::Simple;
use Data::ICal;
use DateTime::Format::ICal;
use DateTime::TimeZone::ICal;
use DBI;
use Getopt::Long;
use MIME::Base64 qw(encode_base64);
use MIME::Parser;

my $meqaris_version = '0.5';
my $meqaris_dbversion = 3;

# ============================ Loggers: ===================================

my $logger = undef;
my $log_level = 0;

eval {
	# some default configuration
	my $config_text = q(
		log4perl.rootLogger = TRACE, Screen

		log4perl.appender.Screen        = Log::Log4perl::Appender::Screen
		log4perl.appender.Screen.stderr = 1
		#log4perl.appender.Screen.layout = Log::Log4perl::Layout::SimpleLayout
		log4perl.appender.Screen.layout = Log::Log4perl::Layout::PatternLayout
		log4perl.appender.Screen.layout.ConversionPattern = [%d{yyyy-MM-dd HH:mm}] %p - %m%n
		);
	use Log::Log4perl;
	Log::Log4perl->init (\$config_text);
	$logger = Log::Log4perl->get_logger('Meqaris');
};

sub log_trace {

	my $msg = shift;

	if ( defined ($logger) && $logger->is_trace () ) {
		$logger->trace ("$msg");
	}
	elsif ( $log_level > 5 ) {
		print STDERR "Meqaris: trace: $msg\n";
	}
}

sub log_debug {

	my $msg = shift;

	if ( defined ($logger) && $logger->is_debug () ) {
		$logger->debug ("$msg");
	}
	elsif ( $log_level > 4 ) {
		print STDERR "Meqaris: debug: $msg\n";
	}
}

sub log_info {

	my $msg = shift;

	if ( defined ($logger) && $logger->is_info () ) {
		$logger->info ("$msg");
	}
	elsif ( $log_level > 3 ) {
		print STDERR "Meqaris: info: $msg\n";
	}
}

sub log_warn {

	my $msg = shift;

	if ( defined ($logger) && $logger->is_warn () ) {
		$logger->warn ("$msg");
	}
	elsif ( $log_level > 2 ) {
		print STDERR "Meqaris: warn: $msg\n";
	}
}

sub log_error {

	my $msg = shift;

	if ( defined ($logger) && $logger->is_error () ) {
		$logger->error ("$msg");
	}
	elsif ( $log_level > 1 ) {
		print STDERR "Meqaris: error: $msg\n";
	}
}

sub log_fatal {

	my $msg = shift;

	if ( defined ($logger) && $logger->is_fatal () ) {
		$logger->fatal ("$msg");
	}
	elsif ( $log_level > 0 ) {
		print STDERR "Meqaris: fatal: $msg\n";
	}
}

# ============================ Command line processing =======================

log_trace 'Reading the command line';

Getopt::Long::Configure('ignore_case', 'ignore_case_always');

my $config_file = '/etc/meqaris.ini';
my $create = '';
my $delete = '';
my $description = '';
my $destroy_db = '';
my $disable = '';
my $email = '';
my $enable = '';
my $help = '';
my $lic = '';
my $name = '';
my $status = '';
my $update = '';
my $upgrade_db = '';
my $version = '';

if ( !GetOptions (
	'conf=s'		=> \$config_file,
	'create=s'		=> \$create,
	'delete=s'		=> \$delete,
	'description=s'		=> \$description,
	'destroy-db'		=> \$destroy_db,
	'disable=s'		=> \$disable,
	'email=s'		=> \$email,
	'enable=s'		=> \$enable,
	'h|help|?'		=> \$help,
	'license|licence'	=> \$lic,
	'name=s'		=> \$name,
	'status'		=> \$status,
	'update=s'		=> \$update,
	'upgrade-db'		=> \$upgrade_db,
	'version'		=> \$version,
	)
   ) {
	print_help();
	exit 1;
}

log_trace 'Processing command line arguments';

if ( $lic ) {
	print
		"Meqaris (Meeting Equipment and Room Invitation System)\n" .
		"- software that allows booking meeting rooms and other resources\n" .
		" using e-mail invitations\n" .
		"Author: Bogdan 'bogdro' Drozdowski, bogdro (at) users . sourceforge . net.\n\n" .
		"  This program is free software: you can redistribute it and/or modify\n" .
		"  it under the terms of the GNU Affero General Public License as published by\n" .
		"  the Free Software Foundation, either version 3 of the License, or\n" .
		"  (at your option) any later version.\n\n" .
		"  This program is distributed in the hope that it will be useful,\n" .
		"  but WITHOUT ANY WARRANTY; without even the implied warranty of\n" .
		"  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n" .
		"  GNU Affero General Public License for more details.\n\n" .
		"  You should have received a copy of the GNU Affero General Public License\n" .
		"  along with this program.  If not, see <http://www.gnu.org/licenses/>.\n"
		;
	exit 0;
}

if ( $help ) {
	print_help();
	exit 0;
}

if ( $version ) {
	print "Meqaris version $meqaris_version\n";
	exit 0;
}

log_debug "Reading configuration file '$config_file'";

my %cfg;
Config::Simple->import_from($config_file, \%cfg);

log_debug "Done reading configuration file '$config_file'";

if ( defined ($cfg{'meqaris.log4perl_config_location'}) && $cfg{'meqaris.log4perl_config_location'} ne '' ) {
	log_debug "Attempting to switch Log4perl to configuration file '" . $cfg{'meqaris.log4perl_config_location'} . "'";
	eval {
		use Log::Log4perl;
		Log::Log4perl->init ($cfg{'meqaris.log4perl_config_location'});
		$logger = Log::Log4perl->get_logger('Meqaris');
	};
}

if ( $status ) {

	log_debug "Got --status";

	my $error = 0;
	if ( Config::Simple->error() ) {
		print "Configuration file '$config_file': ERROR: "
			. Config::Simple->error() . "\n";
		$error = 1;
	} else {
		print "Configuration file '$config_file': OK\n";
	}

	if ( ! $error ) {

		for my $k ('meqaris.dbtype', 'meqaris.datadir',
			'postgresql.username', 'postgresql.password',
			'postgresql.dbname', 'postgresql.host',
			'postgresql.port' ) {

			if ( ! defined ($cfg{$k}) ) {
				print "Configuration file '$config_file': ERROR: Missing: $k\n";
				$error = 1;
			}
		}
	}
	if ( ! $error ) {

		if ( ! -d "$cfg{'meqaris.datadir'}/sql" ) {
			print "Data directory: ERROR: '$cfg{'meqaris.datadir'}/sql' is not a directory\n";
			$error = 1;
		} else {
			print "Data directory: '$cfg{'meqaris.datadir'}': OK\n";
		}
	}
	if ( ! $error ) {

		my $dbh = db_connect();
		if ( ! $dbh ) {
			print "Database connection: ERROR\n";
			$error = 2;
		}
		if ( ! $error ) {
			print "Database connection: OK\n";
			my $db_ver = db_version ($dbh);
			if ( $meqaris_dbversion == $db_ver ) {
				print "Database version: OK\n";
			} else {
				print "Database version: ERROR: expected $meqaris_dbversion, got $db_ver\n" .
					"You may need to run 'meqaris --upgrade-db'.\n";
				$error = 2;
			}
			$dbh->disconnect;
		}
	}
	exit $error;
}

if ( $create ) {

	log_debug "Got --create: name='$create' email='$email' desc='$description'";

	my $dbh = db_connect();
	exit 2 unless $dbh;
	exit 2 unless db_upgrade ($dbh);
	my $stmth = db_stmt ($dbh, 'insert into meqaris.meq_resources(r_name, r_email, r_description) values ($1, $2, $3)');
	exit 2 unless $stmth;
	$stmth->execute(substr ($create, 0, 1000),
		substr ($email, 0, 1000), substr ($description, 0, 1000));
	if ( $dbh->errstr ) {
		log_error "Database: cannot create resource: " . $dbh->errstr . "\n";
		exit 2;
	}
	$dbh->disconnect;
	exit 0;
}

if ( $delete ) {

	log_debug "Got --delete: name='$delete'";

	my $dbh = db_connect();
	exit 2 unless $dbh;
	exit 2 unless db_upgrade ($dbh);
	my $stmth = db_stmt ($dbh, 'delete from meqaris.meq_resources where r_name = $1');
	exit 2 unless $stmth;
	$stmth->execute($delete);
	if ( $dbh->errstr ) {
		log_error "Database: cannot delete resource: " . $dbh->errstr . "\n";
		exit 2;
	}
	$dbh->disconnect;
	exit 0;
}

if ( $destroy_db ) {

	log_debug "Got --destroy-db";

	my $dbh = db_connect();
	exit 2 unless $dbh;
	my $stmth = db_stmt ($dbh, 'drop schema meqaris cascade');
	exit 2 unless $stmth;
	$stmth->execute();
	if ( $dbh->errstr ) {
		log_error "Database: cannot destroy the database schema: " . $dbh->errstr . "\n";
		exit 2;
	}
	$dbh->disconnect;
	exit 0;
}

if ( $disable ) {

	log_debug "Got --disable: name='$disable'";

	my $dbh = db_connect();
	exit 2 unless $dbh;
	exit 2 unless db_upgrade ($dbh);
	my $stmth = db_stmt ($dbh, 'update meqaris.meq_resources set r_enabled = false where r_name = $1');
	exit 2 unless $stmth;
	$stmth->execute($disable);
	if ( $dbh->errstr ) {
		log_error "Database: cannot disable resource: " . $dbh->errstr . "\n";
		exit 2;
	}
	$dbh->disconnect;
	exit 0;
}

if ( $enable ) {

	log_debug "Got --enable: name='$enable'";

	my $dbh = db_connect();
	exit 2 unless $dbh;
	exit 2 unless db_upgrade ($dbh);
	my $stmth = db_stmt ($dbh, 'update meqaris.meq_resources set r_enabled = true where r_name = $1');
	exit 2 unless $stmth;
	$stmth->execute($enable);
	if ( $dbh->errstr ) {
		log_error "Database: cannot enable resource: " . $dbh->errstr . "\n";
		exit 2;
	}
	$dbh->disconnect;
	exit 0;
}

if ( $update ) {

	log_debug "Got --update: name='$name' email='$email' desc='$description'";

	my $dbh = db_connect();
	exit 2 unless $dbh;
	exit 2 unless db_upgrade ($dbh);
	my $sql = 'update meqaris.meq_resources set ';
	my $first = 1;
	my $par_cnt = 2;
	my @values = ($update);
	if ( $name ne '' ) {

		$sql .= "r_name = \$$par_cnt";
		push @values, substr ($name, 0, 1000);
		$first = 0;
		$par_cnt++;
	}
	if ( $email ne '' ) {

		if ( ! $first ) {
			$sql .= ', ';
		}
		$sql .= "r_email = \$$par_cnt";
		push @values, substr ($email, 0, 1000);
		$first = 0;
		$par_cnt++;
	}
	if ( $description ne '' ) {

		if ( ! $first ) {
			$sql .= ', ';
		}
		$sql .= "r_description = \$$par_cnt";
		push @values, substr ($description, 0, 1000);
		$first = 0;
		$par_cnt++;
	}

	$sql .= ' where r_name = $1';

	my $stmth = db_stmt ($dbh, $sql);
	exit 2 unless $stmth;
	$stmth->execute(@values);
	if ( $dbh->errstr ) {
		log_error "Database: cannot update resource: " . $dbh->errstr . "\n";
		exit 2;
	}
	$dbh->disconnect;
	exit 0;
}

if ( $upgrade_db ) {

	log_debug "Got --upgrade-db";

	my $dbh = db_connect();
	exit 2 unless $dbh;
	exit 2 unless db_upgrade ($dbh);
	$dbh->disconnect;
	exit 0;
}

# ============================ Input processing ===================================

log_trace 'Processing standard input';

my $parser = new MIME::Parser;
$parser->output_dir('/tmp');
$parser->output_prefix('meqaris-msg');
my $entity = $parser->parse(\*STDIN) or die "Standard input parsing failed\n";

log_trace 'Standard input processed';

my @parts = $entity->parts;

my $sender = $entity->head->get('From', 0);
chomp $sender;
my $subject = $entity->head->get('Subject', 0);
chomp $subject;
my $reply_sender = '';
my $response_type = '';

log_info "New message from '$sender' with subject '$subject'";

my $dbh = db_connect();
exit 2 unless $dbh;
exit 2 unless db_upgrade ($dbh);

my $res = $dbh->selectall_hashref (db_stmt ($dbh, 
	'select r_id, r_name, r_email, r_enabled from meqaris.meq_resources'), 'r_email');
my $processed = 0;

log_trace 'Processing message parts';

for my $p (@parts) {

	if ( $p->mime_type eq 'text/calendar'
		|| $p->mime_type eq 'application/ics' ) {

		log_info "Message from '$sender' with subject '$subject' contains an iCalendar";

		# bodyhandle() runs the decoding, as_string() doesn't
		my $orig_invitation = $p->bodyhandle->as_string;
		log_debug "Message from '$sender' with subject '$subject' contains this iCalendar:\n" .
			"-----\n$orig_invitation\n------";

		my $ical = Data::ICal->new(data => $orig_invitation);

		# Check the method property. ARRAY! List context required!
		my ($method) = @{$ical->property('METHOD')};
		if ( val($method) ne 'REQUEST' and val($method) ne 'CANCEL' ) {

			log_info "Message from '$sender' with subject '$subject'" .
				" contains an iCalendar, but its method '" .
				val($method) . "' is unsupported. Skipping";
			next;
		}

		my $calendar_reply = Data::ICal->new(rfc_strict => 1);
		# Read the time zones, if any:
		log_trace 'Processing iCalendar time zones';
		my (%vtz, @vevents);
		for my $entry (@{$ical->entries}) {

			my $type = $entry->ical_entry_type;
			if ( $type eq 'VEVENT' ) {

				push @vevents, $entry;
			}
			elsif ( $type eq 'VTIMEZONE' ) {

				my $dtz = DateTime::TimeZone::ICal->from_ical_entry($entry);
				$vtz{$dtz->name} = $dtz;
			}
		}
		log_trace 'Done processing iCalendar time zones. Processing events.';

		# Process events:
		EV: for my $event (@vevents) {

			my ($organizer) = @{$event->property('organizer')};
			my $organizer_mail = undef;
			($organizer_mail = val($organizer)) =~ s/^mailto://io;
			my ($uid) = @{$event->property('uid')};

			log_info "Got event with uid='" . val ($uid) .
				"' and organizer='" . val ($organizer) . "'";
			if ( val ($method) eq 'REQUEST' ) {

				log_trace "Event '" . val($uid) . "': REQUEST";

				# Get the event properties. ARRAY! List context required!
				my ($dtstart) = @{$event->property('dtstart')};
				my ($dtend) = @{$event->property('dtend')};
				my ($dtstamp) = defined ($event->property('dtstamp'))?
					@{$event->property('dtstamp')} : undef;
				my ($sequence) = defined ($event->property('sequence'))?
					@{$event->property('sequence')} : undef;
				my ($summary) = @{$event->property('summary')};

				log_info "Event REQUEST uid='" . val ($uid) .
					"': dtstart='" . val ($dtstart) .
					"', dtend='" . val ($dtend) .
					"', dtstamp='" . val ($dtstamp).
					"', sequence='" . val ($sequence) .
					"', summary='" . val ($summary) . "'";

				# Get the timezone ID from the parameters:
				my $tzid_start = $dtstart->parameters->{'TZID'};
				my $tzid_end = $dtend->parameters->{'TZID'};

				# Convert the dates to the timezone:
				my $dt_start = DateTime::Format::ICal->parse_datetime($dtstart->value);
				my $dt_end = DateTime::Format::ICal->parse_datetime($dtend->value);

				# The datetime is changed to be 'floating'
				$dt_start->set_time_zone($vtz{$tzid_start})
					if $tzid_start and $vtz{$tzid_start};
				$dt_end->set_time_zone($vtz{$tzid_end})
					if $tzid_end and $vtz{$tzid_end};

				log_trace 'Matching attendees to events.';

				# Find an attendee matching one of our resources
				# and set the reply as ACCEPTED if the timeslot is free
				# (if the database allows the insert) and DECLINED
				# otherwise or on any error.
				for my $attendee (@{$event->property('attendee')}) {

					# Get the raw e-mail address:
					($reply_sender = val($attendee)) =~ s/^mailto://io;
					my $updating = 0;
					log_debug "Event '" . val ($uid) .
						"': trying attendee '$reply_sender'";
					# Skip if not one of our resources:
					if ( ! defined ($res->{$reply_sender}) ) {
					
						log_debug "Event '" . val ($uid) .
							"': attendee '$reply_sender' doesn't match";
						next;
					}
					log_debug "Event '" . val ($uid) .
						"': attendee '$reply_sender' found";
					# check if resource is enabled:
					if ( $res->{$reply_sender}->{'r_enabled'} ) {

						log_debug "Event '" . val ($uid) .
							"': attendee '$reply_sender' is enabled - proceeding";
						# Attendee found and enabled. Check if this is an update.
						my @values = (val ($uid));
						my @old_event = @{ $dbh->selectall_arrayref ( # NOTE: selectall_hashref doesn't seem to work
							db_stmt ($dbh, 'select rr_id, rr_organiser from meqaris.meq_resource_reservations where rr_uid = $1'),
							{ Slice => {} }, @values) };
						if (defined ($old_event[0]{'rr_id'}) ) {

							log_info "Event '" . val ($uid) .
								"': is an update";
							# check if the sender is the organizer and decline if not
							my $sender_mail;
							if ( $sender =~ /<([^>]+)>/o ) {
								$sender_mail = $1;
							} else {
								$sender_mail = $sender;
							}
							if ( $sender_mail ne $organizer_mail ) {

								log_info "Event '" . val ($uid) .
									"': sender '$sender_mail' is not iCalendar's organizer '$organizer_mail' - declining";
								$response_type = 'Declined';
								$attendee->parameters->{'PARTSTAT'} = 'DECLINED';
								$calendar_reply->add_entry($event);
								last EV;
							}
							log_debug "Event '" . val ($uid) .
								"': sender '$sender_mail' is iCalendar's organizer '$organizer_mail'";
							$old_event[0]{'rr_organiser'} =~ s/^mailto://io;
							if ( $sender_mail ne $old_event[0]{'rr_organiser'} ) {

								log_info "Event '" . val ($uid) .
									"': sender '$sender_mail' is not the same organizer as in the database '" .
									$old_event[0]{'rr_organiser'} . "' - declining";
								$response_type = 'Declined';
								$attendee->parameters->{'PARTSTAT'} = 'DECLINED';
								$calendar_reply->add_entry($event);
								last EV;
							}
							# start transaction for the DELETE + INSERT
							$dbh->begin_work();
							$updating = 1;
							my $stmth = db_stmt ($dbh,
								'delete from meqaris.meq_resource_reservations ' .
								'where rr_id = $1');
							if ( $stmth ) {
								@values = ($old_event[0]{'rr_id'});
								$stmth->execute(@values);
								if ( $dbh->errstr ) {
									log_error "Event '" . val ($uid) .
										"': error deleting old event: " .
										$dbh->errstr;
									$response_type = 'Declined';
									$attendee->parameters->{'PARTSTAT'} = 'DECLINED';
									$calendar_reply->add_entry($event);
									$dbh->rollback;
									last EV;
								} else {
									log_info "Event '" . val ($uid) .
										"': old event deleted successfully";
								}
							} else {
								log_error "Event '" . val ($uid) .
									"': error deleting old event: " .
									$dbh->errstr;
								$response_type = 'Declined';
								$attendee->parameters->{'PARTSTAT'} = 'DECLINED';
								$calendar_reply->add_entry($event);
								$dbh->rollback;
								last EV;
							}
						}
						# Try to insert the new event:
						log_info "Event '" . val ($uid) .
							"': inserting new event";
						my $stmth = db_stmt ($dbh,
							'insert into meqaris.meq_resource_reservations ' .
							'(rr_r_id, rr_interval, rr_organiser, rr_summary, rr_dtstamp, rr_uid, rr_seq, rr_data) ' .
							'values ($1, $2, $3, $4, $5, $6, $7, $8)');
						if ( $stmth ) {

							my @values = (
								$res->{$reply_sender}->{'r_id'},
								"[$dt_start, $dt_end)",
								substr ($organizer_mail, 0, 1000),
								substr (val ($summary), 0, 1000),
								val ($dtstamp),
								substr (val ($uid), 0, 1000),
								(defined ($sequence))? $sequence->value : 0,
								encode_base64 ($orig_invitation)
								);
							$stmth->execute(@values);
							if ( $dbh->errstr ) {

								log_error "Event '" . val ($uid) .
									"': error inserting new event: " .
									$dbh->errstr . " - declining";
								# DB error - decline
								$response_type = 'Declined';
								$attendee->parameters->{'PARTSTAT'} = 'DECLINED';
								$dbh->rollback if $updating;
							} else {
								log_info "Event '" . val ($uid) .
									"': event inserted for attendee '$reply_sender'";
								$response_type = 'Accepted';
								$attendee->parameters->{'PARTSTAT'} = 'ACCEPTED';
								$dbh->commit if $updating;
							}
						}
						else {
							log_error "Event '" . val ($uid) .
								"': error inserting new event: " .
								$dbh->errstr . " - declining";
							# DB error - decline
							$response_type = 'Declined';
							$attendee->parameters->{'PARTSTAT'} = 'DECLINED';
							$dbh->rollback if $updating;
						}
					}
					else {
						log_info "Event '" . val ($uid) .
							"': resource disabled - declining";
						# Attendee disabled - decline
						$response_type = 'Declined';
						$attendee->parameters->{'PARTSTAT'} = 'DECLINED';
						$dbh->rollback if $updating;
					}
					$calendar_reply->add_entry($event);
					last EV;
				} # for my $attendee
			} # 'REQUEST'
			elsif ( val ($method) eq 'CANCEL' ) {

				log_info "Event '" . val ($uid) . "': CANCEL";

				# Cancellation request - check if the event
				# exists, check if sender is the organiser
				# and if the organiser in the cancellation
				# request is the organiser of the original event
				if ( ! defined ($uid) ) {

					log_info "Event '?': UID not defined, cannot delete - ignoring";
					next;
				}
				log_trace 'Comparing sender and organizer e-mail addresses';
				my $sender_mail;
				if ( $sender =~ /<([^>]+)>/o ) {
					$sender_mail = $1;
				} else {
					$sender_mail = $sender;
				}
				if ( $sender_mail ne $organizer_mail ) {

					log_info "Event '" . val ($uid) .
						"': sender '$sender_mail' is not iCalendar's organizer '$organizer_mail' - ignoring";
					next;
				}
				log_debug "Event '" . val ($uid) .
					"': sender '$sender_mail' is iCalendar's organizer '$organizer_mail'";
				my @values = (val ($uid));
				log_trace "Event '" . val ($uid) .
						"': searching the database";
				my @event = @{ $dbh->selectall_arrayref ( # NOTE: selectall_hashref doesn't seem to work
					db_stmt ($dbh, 'select rr_id, rr_organiser from meqaris.meq_resource_reservations where rr_uid = $1'),
					{ Slice => {} }, @values) };
				if (! defined ($event[0]{'rr_id'}) ) {

					log_info "Event '" . val ($uid) .
						"': not found in database - ignoring: " . $dbh->errstr;
					next;
				}
				log_trace "Event '" . val ($uid) .
						"': found in the database";
				$event[0]{'rr_organiser'} =~ s/^mailto://io;
				if ( $sender_mail ne $event[0]{'rr_organiser'} ) {

					log_info "Event '" . val ($uid) .
						"': sender '$sender_mail' is not the same organizer as in the database '" .
						$event[0]{'rr_organiser'} . "' - ignoring";
					next;
				}
				my $stmth = db_stmt ($dbh,
					'delete from meqaris.meq_resource_reservations ' .
					'where rr_id = $1');
				if ( $stmth ) {
					@values = ($event[0]{'rr_id'});
					$stmth->execute(@values);
					if ( $dbh->errstr ) {
						log_error "Event '" . val ($uid) .
							"': error deleting event: " .
							$dbh->errstr;
					} else {
						log_info "Event '" . val ($uid) .
							"': event deleted successfully";
					}
				} else {
					log_error "Event '" . val ($uid) .
						"': error deleting event: " .
						$dbh->errstr;
				}

			} # 'CANCEL'
		}
		if ( $response_type ne '' ) {

			log_debug "Preparing response to '$sender'";

			$calendar_reply->add_property('PRODID', "Meqaris $meqaris_version");
			$calendar_reply->add_property('METHOD', 'REPLY');
			my $mail = MIME::Entity->build (
				#Type => 'multipart/mixed', # set automatically
				From => $reply_sender,
				To => $sender,
				Subject => substr ("$response_type: $subject", 0, 78), # length - rfc2822
				Encoding => 'quoted-printable',
				Data => [
						"$response_type: $subject\n",
						"-- \n",
						"Generated by Meqaris version $meqaris_version\n"
					]
			);
			$mail->head->add('Comments', "Generated by Meqaris version $meqaris_version");
			$mail->attach(
				Data => $calendar_reply->as_string,
				Type => 'text/calendar; method=REPLY',
				Encoding => 'base64'
			);
			log_debug "Response mail:\n=====\n" . $mail->stringify . "\n=====";
			my $mail_sending_method = db_get_config ($dbh, 'mail_sending_method');
			if ( defined ($mail_sending_method) && $mail_sending_method eq 'mail_command' ) {

				# send by piping the mail to a command
				my $mail_command = db_get_config ($dbh, 'mail_command');
				if ( defined ($mail_command) && $mail_command ne '' ) {

					# remove any pipe symbols first:
					$mail_command =~ s/^\s*\|\s*//o;
					log_info "Sending response to '$sender' using command '$mail_command'";
					open (my $cmd, '|-', $mail_command);
					if ( ! $cmd ) {
						log_warn "Mail_sending_method = mail_command, but mail_command failed to run: $!." .
							' Cannot send the response.';
					}
					print $cmd $mail->stringify;
					close $cmd;
				}
				else {
					log_warn 'Mail_sending_method = mail_command, but mail_command was not defined.' .
						' Cannot send the response.';
				}
			}
			else {
				# send by mail (the default)
				my %send_cfg = (
					MailFrom => $reply_sender,
					To => $sender);
				my $mail_server = db_get_config ($dbh, 'mail_server');
				my $mail_server_port = db_get_config ($dbh, 'mail_server_port');
				$send_cfg{Host} = $mail_server if defined ($mail_server) && $mail_server ne '';
				$send_cfg{Port} = $mail_server_port if defined ($mail_server_port) && $mail_server_port ne '';
				$send_cfg{Debug} = 1 if defined ($logger) && $logger->is_trace (); # prints to screen

				log_info "Sending response to '$sender' using " .
					"mail_server:port='" .
					(defined ($mail_server)? $mail_server : '(default)') .
					':' . (defined ($mail_server_port)? $mail_server_port : '(default port)') ."'";
				$mail->smtpsend(%send_cfg);
			}
			$processed = 1;
		}
	}	# $p->mime_type eq 'text/calendar' || $p->mime_type eq 'application/ics'
	# Process just one invitation per each e-mail. Various mail clients
	# may sen the same invitation using different MIME types, so reply
	# to just the first one successfully processed and stop processing
	# to avoid conflicts and unnecessary meeting rejections.
	last if $processed;
}

$parser->filer->purge;

exit 0;

# ============================ Subroutines: ===================================

# ============================ print_help ===================================

sub print_help {

	print
		"Meqaris (Meeting Equipment and Room Invitation System)\n" .
			"- software that allows booking meeting rooms and other resources\n" .
			" using e-mail invitations\n" .
			"Author: Bogdan 'bogdro' Drozdowski, bogdro (at) users . sourceforge . net.\n\n" .
			"Syntax: meqaris [options]\n\n" .
			"Options:\n" .
			"--conf <file>\t\t\tUse the given configuration file\n" .
			"--create <name>\t\t\tCreate a new meeting resource\n" .
			"--delete <name>\t\t\tDelete a meeting resource with the given name\n" .
			"--description <desc>\t\tSpecifies a description for a meeting resource when creating or updating\n" .
			"--destroy-db\t\t\tDestroys the Meqaris schema on the database\n" .
			"--disable <name>\t\tDisables the meeting resource with the given name\n" .
			"--email <e-mail address>\tSpecifies an e-mail address for the meeting resource when creating or updating\n" .
			"--enable <name>\t\t\tEnables the meeting resource with the given name\n" .
			"-h|--help|-?\t\t\tShows this help message\n" .
			"--license|licence\t\tShows the license information\n" .
			"--name <name>\t\t\tSpecifies a new name for the meeting resource when updating\n" .
			"--status\t\t\tShows the operatibility status of Meqaris\n" .
			"--update <name>\t\t\tUpdate a meeting resource with the given name\n" .
			"--upgrade-db\t\t\tRun the necessary Meqaris database structure upgrade scripts\n" .
			"--version\t\t\tDisplay Meqaris version information\n"
		;
}

# ============================ val ===================================

sub val {

	my $prop = shift;
	return (defined ($prop)? $prop->value : '(undef)');
}

# ============================ db_connect ===================================

sub db_connect {

	my $dbh = DBI->connect(
		"dbi:Pg:dbname=$cfg{'postgresql.dbname'};" .
		"host=$cfg{'postgresql.host'};" .
		"port=$cfg{'postgresql.port'};", 
		$cfg{'postgresql.username'},
		$cfg{'postgresql.password'},
		{AutoCommit => 1, RaiseError => 0, PrintError => 0});
	if ( ! $dbh ) {
		log_fatal "Database: cannot connect: " . $DBI::errstr . "\n";
	}
	return $dbh;
}

# ============================ db_stmt ===================================

sub db_stmt {

	my $dbh = shift;
	my $sql = shift;
	my $stmth = $dbh->prepare ($sql);
	if ( ! $stmth ) {
		log_fatal "Database: cannot create statement: " . $dbh->errstr . "\n";
	}
	return $stmth;
}

# ============================ db_get_config ===================================

sub db_get_config {

	my $dbh = shift;
	my $param_name = shift;
	my $stmth = db_stmt ($dbh, 'select c_value from meqaris.meq_config where c_name = $1');
	return 0 unless $stmth;
	$stmth->execute($param_name);
	if ( $dbh->errstr ) {
		log_error "Database: cannot get configuration parameter '$param_name': " . $dbh->errstr . "\n";
		return 0;
	}
	my $db_ver = $stmth->fetchrow_arrayref;
	return $db_ver->[0];
}

# ============================ db_version ===================================

sub db_version {

	my $dbh = shift;
	my $stmth = db_stmt ($dbh, "select c_value from meqaris.meq_config where c_name = 'db_version'");
	return 0 unless $stmth;
	$stmth->execute();
	if ( $dbh->errstr ) {
		# this CAN be a normal situation, e.g. on first install
		log_debug "Database: ERROR: cannot get version: " . $dbh->errstr . "\n";
		return 0;
	}
	my $db_ver = $stmth->fetchrow_arrayref;
	return $db_ver->[0];
}

# ============================ db_run_file ===================================

sub db_run_file {

	my $dbh = shift;
	my $filename = shift;

	open (my $f, '<', $filename);
	if ( ! defined ($f) ) {

		log_fatal "Database upgrade: cannot open file '$filename': $!\n";
		return 0;
	}
	my @lines = <$f>;
	close $f;

	my $stmth = db_stmt ($dbh, join ("\n", @lines));
	return 0 unless $stmth;
	$stmth->execute();
	if ( $dbh->errstr ) {
		log_fatal "Database upgrade: cannot execute file '$filename': " . $dbh->errstr . "\n";
		return 0;
	}
	return 1;
}

# ============================ db_upgrade ===================================

sub db_upgrade {

	my $dbh = shift;
	my $db_ver = db_version ($dbh);

	if ( $meqaris_dbversion != $db_ver ) {

		if ( $db_ver == 0 ) {

			# new database - just run the full script (in a transaction)
			$dbh->begin_work();
			if (! db_run_file ($dbh, "$cfg{'meqaris.datadir'}/sql/meqaris-full.pgsql") ) {

				log_fatal "Can't update database version to $meqaris_dbversion.\n";
				$dbh->rollback();
				return 0;
			}
			$dbh->commit();
		}
		elsif ($db_ver < $meqaris_dbversion) {

			# run just the missing scripts, one at a time, each
			# in its own transaction
			for (my $i = $db_ver + 1; $i <= $meqaris_dbversion; $i++) {

				$dbh->begin_work();
				if (! db_run_file ($dbh, "$cfg{'meqaris.datadir'}/sql/meqaris-v$i.pgsql") ) {

					log_fatal "Can't update database version from $db_ver to $meqaris_dbversion\n";
					$dbh->rollback();
					return 0;
				}
				$dbh->commit();
			}
		}
		elsif ($db_ver > $meqaris_dbversion) {

			log_warn "Database version $db_ver is newer than the expected version $meqaris_dbversion.\n" .
				"The application may behave improperly.\n" .
				"You can continue or leave and install the correct application version.\n";
			return 0;
		}
	}
	return 1;
}
